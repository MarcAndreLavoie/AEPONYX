/*******************************************************************************
 * © 2017 AEPONYX Inc.  All Rights Reserved.
 *
 * THIS SOFTWARE OR FILE ("Software") CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION THAT IS THE PROPERTY OF AEPONYX INC ("AEPONYX") OR ITS LICENSORS, AND IS SUBJECT TO LICENSE TERMS.  If you have a signed license agreement with AEPONYX or a AEPONYX subsidiary for the product(s) with which this Software will be used, your use of this Software is subject to the scope of license and the software protection and security provisions of that agreement.  
 *
 * DISCLAIMER:  NOTWITHSTANDING ANYTHING TO THE CONTRARY IN YOUR SIGNED LICENSE AGREEMENT OR THE EULA, THIS SOFTWARE IS PROVIDED "AS IS" WITH ALL FAULTS AND WITH:
 *
 * (A)          NO WARRANTY OF ANY KIND, express, implied or statutory, including any implied warranties of merchantability or fitness for a particular purpose, which AEPONYX disclaims to the maximum extent permitted by applicable law; and
 *
 * (B)          NO INDEMNIFICATION FOR INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS.
 *
 * LIMITATION OF LIABILITY:  Because this Software is provided "AS IS", NEITHER AEPONYX NOR ITS LICENSORS SHALL BE LIABLE FOR ANY DAMAGES WHATSOEVER IN CONNECTION WITH THE SOFTWARE OR ITS USE.  Without limiting the foregoing, in no event will AEPONYX or its licensors be liable for indirect, special, incidental, or consequential damages (including lost profits or savings) whether based on contract, tort (including negligence), strict liability, or any other legal theory, even if AEPONYX or its licensors have been advised of the possibility of such damages.  THE FOREGOING LIMITATIONS SHALL APPLY TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW.
 *
 * Unless otherwise agreed in writing, AEPONYX has no obligation to support or otherwise maintain Software.
 *******************************************************************************/
 /*******************************************************************************
 * Macro Name: ConnectOpticalPort
 * Creator: Martin Berard
 *
 * Revision History: Version 1.0
 * 30 Nov 2017	Generated by L-Edit
 *******************************************************************************/
#include <cstdlib>
#include <cstdarg>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <cmath>
#include <string>
#include <dubins.h>

#define EXCLUDE_LEDIT_LEGACY_UPI

#include <ldata.h>
/* Begin -- Uncomment this block if you are using L-Comp. */
#include <lcomp.h> // LC_Microns
/* End */

extern "C" {
	void ConnectOpticalPort(void);
   int printConfiguration(double, double, void*);
	int UPI_Entry_Point(void);
	LLayer CheckLayer(LFile pTDBFile, const char* szLayerName, const char* szLayerTitle);
	LLen Round(LFile pTDBFile, LLen r_length);
}

//*************************************************************************
//* PROTOTYPES
//*************************************************************************

	
int printConfiguration(double q[3], double x, void* user_data) {
    LUpi_LogMessage(LFormat("%f, %f, %f, %f\n", q[0], q[1], q[2], x));
    return 0;
}

int WGpolygon(double q[3], double x, void* user_data) {
    LCoord XC = 0;
	 LCoord YC = 0;
	 XC = LC_Microns (-10.0);
    YC = LC_Microns (-20.0);
	 LPoint * my_polygon = (LPoint *)user_data;
	 LUpi_LogMessage(LFormat("WGpolygon:  x0:%ld, y0:%ld / x1:%ld, y1:%ld\n", my_polygon[0].x, my_polygon[0].y, my_polygon[1].x, my_polygon[1].y)); 
    my_polygon[0] = LPoint_Set(XC, YC);
    XC = LC_Microns (30.0);
    YC = LC_Microns (40.0);
    my_polygon[1] = LPoint_Set(XC, YC);
    LUpi_LogMessage(LFormat("WGpolygon:  x0:%ld, y0:%ld / x1:%ld, y1:%ld\n", my_polygon[0].x, my_polygon[0].y, my_polygon[1].x, my_polygon[1].y));
    return 0;
}

void ConnectOpticalPort (void)  //LLabel InputPort, LLabel OutputPort
{
   char sLayerName[MAX_LAYER_NAME];
	char sCellName[MAX_CELL_NAME];
	char sTDBFileName[MAX_TDBFILE_NAME];
	
	int err=0;
		
	double q0[] = {0.0, 0.0, 0};
	double q1[] = {20.0, 10.0, 0};
	double turning_radius=10.0;
   DubinsPath path;
  
   if (dubins_init(q0,q1,turning_radius,&path))
   {
   	assert(err == 0);
   	LUpi_LogMessage(LFormat("Dubins Call Result:%d\n",err));
   }
   
   LUpi_LogMessage(LFormat("qi[0]: %lf, qi[1]: %lf, qi[2]: %lf.\n",path.qi[0],path.qi[1],path.qi[2]));
   LUpi_LogMessage(LFormat("lenth[0]: %lf, length[1]: %lf, length[2]: %lf, curve length: %lf.\n",path.param[0],path.param[1],path.param[2], path.param[0]+path.param[2]));
   LUpi_LogMessage(LFormat("rho: %lf, type: %d.\n",path.rho,path.type));
	
	LUpi_LogMessage(LFormat("First section angle: %lf.\n", (180/M_PI)*(path.param[0])));
	LUpi_LogMessage(LFormat("Straight section: %lf.\n", path.param[1]*path.rho));
	LUpi_LogMessage(LFormat("Second section angle: %lf.\n", (180/M_PI)*(path.param[2])));
	
   //dubins_path_sample_many( &path, printConfiguration, 0.1, NULL);
   
   LPoint polygon_point_arr[2]; /* length / step * rho 10µm = 229 * 2D */
   LCoord XT = 0;
	LCoord YT = 0;
	XT = LC_Microns (-1.1);
   YT = LC_Microns (-2.2);
   polygon_point_arr[0] = LPoint_Set(XT, YT);
   XT = LC_Microns (3.3);
   YT = LC_Microns (4.4);
   polygon_point_arr[1] = LPoint_Set(XT, YT);
   dubins_path_sample_many( &path, WGpolygon, 0.1, (void *) polygon_point_arr);
		
   /* display information about the specific words */
   
	LCell pCell = LCell_GetVisible(); 		// The current cell.
	if(NotAssigned(pCell))
	{
		LDialog_AlertBox("ERROR:  Could not find a Visible Cell.");
		return;
	}
   LCell_GetName(pCell, sCellName, MAX_CELL_NAME);
   LDialog_AlertBox(LFormat("The Polygon will be added in Cell %s", sCellName)); 

   
   LFile pTDBFile = LCell_GetFile(pCell);		// The TDB current file.
		if(NotAssigned(pTDBFile))
		{
			LDialog_AlertBox("ERROR:  Could not get the TDB file from the Visible Cell.");
			return;
		}
   LFile_GetName(pTDBFile, sTDBFileName, MAX_TDBFILE_NAME);
   LDialog_AlertBox(LFormat("The Polygon will be added in TDB File %s", sTDBFileName));
	
	LLayer pLayer = LLayer_Find(pTDBFile, "WGUIDE");
		if(NotAssigned(pLayer)) 
		{
			LDialog_AlertBox("ERROR:  Could not get the Layer WGUIDE Visible Cell.");
			return;
		}
	LLayer_GetName(pLayer, sLayerName, MAX_LAYER_NAME);
   LDialog_AlertBox(LFormat("The Polygon will be added in Layer %s", sLayerName)); 	
   
  /* 
 //seg1  
   LCoord XC = LC_Microns (0.0);
   LCoord YC = LC_Microns (10.0);
   LPoint Seg_Center = {.y=YC, .x=XC};
   LTorusParams Seg_Params ={.ptCenter=Seg_Center, .nInnerRadius = LC_Microns (9), .nOuterRadius=LC_Microns (11.0), .dStartAngle=270, .dStopAngle=270+(180/M_PI)*path.param[0]};
 	LTorus_CreateNew( pCell, pLayer, &Seg_Params );
 
 //seg2
 
 	LPoint point_arr[4];
 	XC = 
   point_arr[nPoints] = LPoint_Set(XC, YC);
  	LPolygon_New(pCell, myLayer, point_arr, nPoints);
 

 //seg3
   XC = LC_Microns (20.0);
   YC = LC_Microns (0.0);
	Seg_Center.x=XC;
	Seg_Center.y=YC;
	Seg_Params.ptCenter=Seg_Center;
	Seg_Params.nInnerRadius = LC_Microns (9);
	Seg_Params.nOuterRadius=LC_Microns (11.0);
	Seg_Params.dStartAngle=90;
	Seg_Params.dStopAngle=90+(180/M_PI)*path.param[0];
	LTorus_CreateNew( pCell, pLayer, &Seg_Params );
*/	

   LUpi_LogMessage(LFormat("A polygon will be added:  x0:%ld, y0:%ld / x1:%ld, y1:%ld\n", polygon_point_arr[0].x, polygon_point_arr[0].y, polygon_point_arr[1].x, polygon_point_arr[1].y));
   LPolygon_New(pCell, pLayer, polygon_point_arr, 2);
	LDisplay_Refresh();
 /*  
   
   switch (path.type) 
	{
		case 1
		break;
		
		case 2
			
			Seg1_Param.ptCenter=(0,10);
   		Seg1_Param.nInnerRadius;
   		Seg1_Param.nOuterRadius;
   		Seg1_Param.dStartAngle;
      	Seg1_Param.dStopAngle;
			LTorus_CreateNew( pCell, pLayer, *Seg1_Params )
		break;
		
		case 3
		break;
		
		case 4
		break
		
		case 5
		break
		
		case 6
		break
	}
*/
/*	
	LPoint WGPolygon[4];
	WGPolygon[0]=LPoint_Set(LFile_DispUtoIntU(pTDBFile,10), LFile_DispUtoIntU(pTDBFile,9.7825));
	WGPolygon[1]=LPoint_Set(LFile_DispUtoIntU(pTDBFile,10), LFile_DispUtoIntU(pTDBFile,10.2175));
	WGPolygon[2]=LPoint_Set(LFile_DispUtoIntU(pTDBFile,110), LFile_DispUtoIntU(pTDBFile,10.2175));
	WGPolygon[3]=LPoint_Set(LFile_DispUtoIntU(pTDBFile,110), LFile_DispUtoIntU(pTDBFile,9.7825));
	LPolygon_New(pCell, pLayer, WGPolygon, 4);
	LDisplay_Refresh();
*/


}
//*************************************************************************
// Function Name    : CheckLayer
// Parameters       : pTDBFile
//                    szLayerName
//                    szLayerTitle
// Description      : 
// Returns          : 
//*************************************************************************
//  Revision History
//   03/11/2003 - NJW - Created function.
//*************************************************************************
LLayer CheckLayer(LFile pTDBFile, const char* szLayerName, const char* szLayerTitle)
{
	LLayer pLayer = LLayer_Find(pTDBFile, szLayerName);
	if(NotAssigned(pLayer))
	{
		LDialog_AlertBox(LFormat("Error:  Couldn't find the %s Layer in the TDB File.\nLayer:  \"%s\"\nPlease check the spelling and make sure the layer exists.",  szLayerTitle, szLayerName));
	}
	return(pLayer);
}

LLen Round(LFile pTDBFile, LLen r_length)
{
	LLen R_out;
	long R_long;
	float value;
	value = (LFile_IntUtoMicrons(pTDBFile, r_length)+0.0005)*1000;  //floor +0. round +0.0005
	R_long =(long) value;
	R_out = LFile_DispUtoIntU(pTDBFile, R_long/1000.0);
	//LDialog_AlertBox(LFormat("R_out = %lf",LFile_IntUtoMicrons(pTDBFile, R_out  )));
	return(R_out);
}

int UPI_Entry_Point(void)
{
	LMacro_BindToMenuAndHotKey_v9_30("Tools", "F2" /*hotkey*/, "Connect Optical Port", "ConnectOpticalPort", NULL /*hotkey category*/);
	return 1;
}
